extends TileMap

var gridsize = 5
var dic = {}
var last_tile = Vector2.ZERO  # Store last modified tile

var TokenScene_X = preload("res://tokens/token_X.tscn")
var TokenScene_O = preload("res://tokens/token_O.tscn")
var TokenScene_Grid = preload("res://tokens/ttt_grid.tscn")

func _ready():
	for x in gridsize * 2:
		for y in gridsize:
			dic[Vector2i(x, y)] = { "Position": Vector2i(x, y) }  # Store Vector2i keys
			set_cell(0, Vector2(x, y), 0, Vector2i(0,0), 0)

  #This For loop is what Peter added onto Wades blank table script
	for i in range(5):
		var token = TokenScene_X.instantiate()
		token.position = Vector2(150 + i * 64, 125)  
		add_child(token)  
		var token_O = TokenScene_O.instantiate()
		token_O.position = Vector2(150 + i * 64, 500)
		add_child(token_O) 
		
	var token_Grid = TokenScene_Grid.instantiate()
	var center_tile = Vector2i(gridsize, gridsize / 2)
	token_Grid.position = map_to_local(center_tile)
	add_child(token_Grid)



func _process(_delta):
	var tile = local_to_map(get_global_mouse_position())
	tile = Vector2i(tile.x, tile.y)  # Convert tile to Vector2i

	print("Checking tile:", tile, "Exists:", dic.has(tile))  # Debugging

	erase_cell(1, last_tile)  # Only erase last modified tile

	if dic.has(tile):
		set_cell(1, tile, 1, Vector2i(0,0), 0)
		last_tile = tile
