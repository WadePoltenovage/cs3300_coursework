extends Control

# Cache node references for easier access later
@onready var chat_log = get_node("VBoxContainer/RichTextLabel")
@onready var input_label = get_node("VBoxContainer/HBoxContainer/Label")
@onready var input_field = get_node("VBoxContainer/HBoxContainer/LineEdit")

# Preload token scenes for spawning later
var TokenScene_X = preload("res://tokens/token_X.tscn")
var TokenScene_O = preload("res://tokens/token_O.tscn")

# Chat group data with name and associated color
var groups = [
	{'name': 'Team', 'color': '#00abc7'},
	{'name': 'Match', 'color': '#ffdd8b'},
	{'name': 'Global', 'color': '#ffffff'}
]
var group_index = 0
var user_name = 'Player'

func _ready():
	# Connect the LineEdit signal to submit chat messages
	input_field.text_submitted.connect(text_entered)
	change_group(0)

func _input(event):
	# Handle key input for usability features
	if event is InputEventKey:
		if event.pressed:
			match event.keycode:
				KEY_ENTER:
					input_field.grab_focus()	# Focus input box
				KEY_ESCAPE:
					input_field.release_focus()	# Unfocus input
				KEY_TAB:
					change_group(1)	# Cycle to next chat group

func change_group(value):
	# Cycle through chat groups
	group_index += value
	if group_index >= groups.size():
		group_index = 0
	input_label.text = "[" + groups[group_index]['name'] + "]"
	input_label.set("theme_override_colors/font_color", Color(groups[group_index]['color']))

func add_message(username: String, text: String, group := 0, color := ""):
	chat_log.append_text("\n")
	
	# Use specified color or default to group color
	var color_tag = color if color != "" else groups[group]['color']
	var message = "[color=" + color_tag + "]"
	if username != "":
		message += "[" + username + "]: "
	message += text + "[/color]"
	
	chat_log.append_text(message)
	chat_log.scroll_to_line(chat_log.get_line_count())  # Auto-scroll to bottom

func text_entered(text: String):
	# Process user input commands
	if text.strip_edges() == "/h":
		#add_message("", "There is no help message yet!", 0, "#ff5757")	
		var commands = [
			"/h - Display commands",
			"/roll - Roll a dice",
			"/spawn x - Generate a X",
			"/spawn X - Generate a X",
			"/spawn o - Generate a O",
			"/spawn O - Generate a O"
		]
		
		for cmd in commands:
			add_message("", cmd, 0, "#87ceeb")  # light blue text for help
		
	elif text.begins_with("/roll "):
		var roll_expression = text.substr(6, text.length()).strip_edges()
		var result = roll(roll_expression)
		add_message("System", "ğŸ² " + user_name + " rolled " + roll_expression + " = " + str(result), 0, "#57ff5f")
	elif text.strip_edges() == "/spawn x" || text.strip_edges() == "/spawn X":
		var token = TokenScene_X.instantiate()
		token.position = Vector2(64,64)
		get_tree().current_scene.add_child(token)
		add_message("", "Spawned a token!", 0, "#99ff99")
	elif 	text.strip_edges() == "/spawn O" || text.strip_edges() == "/spawn o":
		var token = TokenScene_O.instantiate()
		token.position = Vector2(64,64)
		get_tree().current_scene.add_child(token)
		add_message("", "Spawned a token!", 0, "#99ff99")
	else:
		add_message(user_name, text.strip_edges(), group_index)
		print("Message sent:", text)
	input_field.text = ""  # Clear the input field
	

var rng = RandomNumberGenerator.new()


func roll(roll_expression):
	
	rng.randomize()
	
	var total = 0
	var terms = parse_expression(roll_expression)
	
	for term in terms:
		var result = evaluate_term(term)
		if result != null:
			total += result
		else:
			print("Invalid term: %s" % term)
	
	print("Total result: %d" % total)


func parse_expression(expr: String) -> Array:
	var pattern = RegEx.new()
	# Matches terms like "+1d6", "-2d4", "+5", "-3"
	pattern.compile(r"([+-]?[^+-]+)")
	var matches = pattern.search_all(expr.strip_edges())
	var terms = []
	for match in matches:
		terms.append(match.get_string(0))
	return terms


func evaluate_term(term: String) -> int:
	term = term.strip_edges()
	var sign = 1
	if term.begins_with("-"):
		sign = -1
		term = term.substr(1)
	elif term.begins_with("+"):
		term = term.substr(1)

	if term.find("d") != -1:
		var parts = term.split("d")
		if parts.size() == 2:
			var count = int(parts[0])
			var sides = int(parts[1])
			var subtotal = 0
			print("Rolling %dd%d..." % [count, sides])
			if count <= 999:
				for i in count:
					var roll = rng.randi_range(1, sides)
					print("Roll %d: %d" % [i + 1, roll])
					subtotal += roll
				print("Subtotal for %s: %d" % [term, subtotal * sign])
				return subtotal * sign
			elif count > 999:
				print("Please roll 999 or less dice")	
			return 0
	else:
		var flat = int(term)
		print("Flat modifier: %d" % (flat * sign))
		return flat * sign
	
	return 0
